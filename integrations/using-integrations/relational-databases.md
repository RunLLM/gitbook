# Relational Databases

{% hint style="info" %}
Before starting, make sure you've added a connection to your database (see [adding-an-integration](../adding-an-integration/ "mention")).

In this guide, we'll use the Aqueduct Demo DB, but this guide will work for any relational database.
{% endhint %}

Most data scientists we've worked with start with some data in a relational database, so that's where we'll start too.&#x20;

First, we're going to get a connection to your database by calling `.integration()` on the Aqueduct Client.&#x20;

```python
demo_db = client.integration('aqueduct_demo')
```

### Reading From a DBMS

Once we have a connection to our database, we can simply call `.sql()` on the connection to execute a SQL query:

```python
customers = demo_db.sql('SELECT * FROM customers;')
```

This returns what we call an [**Artifact**](../../artifacts.md) **** in Aqueduct terminology. An artifact is simply just a wrapper around some data that we'll track a part of your workflow. You can call [Operators](../../operators.md) on your artifacts -- for more on this, see the guide on [Operators](../../operators.md) or [Workflows](../../workflows/).

{% hint style="warning" %}
Every SQL database has a slightly different dialect of SQL, and Aqueduct does not check for the correctness of your query.&#x20;

In order to validate that your query works correctly, call `.get()` on the artifact Aqueduct returns to you. If there's an error, you will be notified immediately.
{% endhint %}

### Reading Using a Chain of Queries
Aqueduct supports extracting from a database using a chain of queries. This allows you to break down complex queries into smaller pieces for better readability.

To do so, simply call `.sql()` with a list of strings. In the query chain, you can use the special placeholder `$` refering to the previous output in the chain. The output of the last query will be returned as the output artifact of this execution.

Example:

```python
customers = demo_db.sql([
  'SELECT * FROM customers WHERE company_size < 50;',
  'SELECT * FROM $ WHERE n_workflows < 10;', # `$` represents the output of the above query.
  'SELECT cust_id AS id, n_data_eng FROM $;', # The output of this query will be returned.
])
```

This example returns the `cust_id` and `n_data_eng` of all customers with `company_size < 50` and `n_workflows < 10`. Under the hood, we compile this chain to a single query using a `WITH` clause, and the compiled query is executed:

```sql
WITH
  tmp_0 AS (SELECT * FROM customers WHERE company_size < 50),
  tmp_1 AS (SELECT * FROM tmp_0 WHERE n_workflows < 10)
SELECT cust_id AS id, n_data_eng FROM tmp_1;
```

### Reading from MongoDB
Aqueduct supports reading from an [MongoDB](https://www.mongodb.com/) integration using Mongo's `.find()` [API](https://pymongo.readthedocs.io/en/stable/api/pymongo/collection.html#pymongo.collection.Collection.find). First, you would need to access the mongo collection using `.collection()` API over the integration. Then you can call `.find()` method to obtain a table artifact just like a mongo `Collection` [object](https://pymongo.readthedocs.io/en/stable/api/pymongo/collection.html#pymongo.collection.Collection).

Example:
```python
mongo_db = client.integration("my_mongo_integration") # connect to the integration
# The following is equivalent to
# `SELECT review FROM hotel_reviews WHERE nationality=" United Kingdom "`
# in SQL.
reviews = mongo_db.collection("hotel_reviews").find(
  {"nationality": " United Kingdom "},
  projection={"_id": 0, "review": 1},
)
```

Aqueducts supports all `args` and `kwargs` for the MongoDB's `.find()` [method](https://pymongo.readthedocs.io/en/stable/api/pymongo/collection.html#pymongo.collection.Collection.find). We simply call this method for you under the hood. Additionally, you can pass Aqueduct's internal keyword arguments to specify the behavior of this operator. Currently we support two arguments:
* `name`: `str`, give this operator and the generated artifact a name.
* `lazy`: `bool`, specify if Aqueduct should run this operator lazily (see [lazy vs. eager execution](../../operators/lazy-vs.-eager-execution.md "mention"))

Please note you **MUST** pass them as **keyword arguments**.

Example:
```python
reviews = mongo_db.collection("hotel_reviews").find(
  {"nationality": " United Kingdom "},
  projection={"_id": 0, "review": 1},
  name="UK reviews", # this will appear in your UI.
  lazy=True, # this operator will execute lazily.
)
```

### Writing to an RDBMS

In order to save an aritfact to a database, you can call `.save()` on the integration. `.save()` expects information about which system to write the artifact to and what configuratin parameters are necessary. This configuration can be generated by calling `.config` on your integration object. For relational databases, the following parameters are required:

* `table_name`: the name of the table that will be created when this artifact is written into this database
* `update_mode`: this can be either `append`, `replace`, or `fail`:
  * `append`: In append mode, the data in this artifact will be appended to an existing table (if it exists); if the table does not exist, a new table will be created. If the existing schema does not match the schema of the new data, an error will be thrown.
  * `replace`: In replace mode, the an existing table of the same name will be completely wiped and replaced with the new data -- this mode does not require the old and new schemas to be compatible.
  * `fail`: In failure mode, the write operation will fail if a table of the same name already exists.

```python
demo_db.save(customers, table_name='customers_duplicate', update_mode='replace')
```

### Writing to MongoDB

Aqueduct supports two ways to specify a config for saving to a [MongoDB](https://www.mongodb.com/) integration: 

```python
# Specify by calling `.save()` on the integration representing Mongo's Database Object.
mongo_db.save(customers, collection='customers_duplicate', update_mode='replace')
# or specify by calling `.save()` directly on the integration representing the MongoDB Collection Object:
mongo_collection = mongo_db.collection('customers_duplicate').save(customers, update_mode='replace')
```